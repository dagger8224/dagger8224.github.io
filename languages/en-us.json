{
    "languages": {
        "en-us": "English",
        "zh-cn": "中文（简体）"
    },
    "viewOnGithub": "view on Github",
    "try": "Try it yourself:",
    "run": "run",
    "reset": "reset",
    "view": "View the result:",
    "overview": "Overview",
    "directive": "Directive",
    "index": "Index",
    "version": "Version",
    "next": "Next",
    "previous": "Prev",
    "overview.introduction": "Overview/introduction",
    "overview.introduction.sections": [{
        "question": "What is dagger.js",
        "answer": "<span>dagger.js is a html-based open source (<a target='_blank' href='https://opensource.org/licenses/MIT'>MIT</a>) web frontend framework. Powered by dagger.js, you could easily build your website (either single page application or simple dynamic web page) or reusable modules with <a target='_blank' href='https://stackoverflow.com/questions/20435653/what-is-vanillajs'>VanillaJS</a>.</span>"
    }, {
        "question": "Who is suitable to use dagger.js",
        "answer": "<span>Either as an experienced professional programer or an amateur interested in web development, you will understand dagger.js in a short time in case you have basic background knowledge for <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTML'>html</a>/<a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript'>javaScript</a>/<a target='_blank' href='https://developer.mozilla.org/en-US/docs/web/CSS'>css</a>. dagger.js works in the form of <a href='directive/introduction'>directive</a> expressions and <a href='miscellaneous/introduction'>configs</a>, in most cases, users do not need to call any framework <a href='api/introduction'>api</a> to complete code development.</span>"
    }, {
        "question": "How to use dagger.js",
        "answer": "<span>dagger.js is a lightweight and complete client side runtime framework with no dependency on any third-party code or build tools. Users may build a development environment and start coding based on the following steps quickly:<div class=\"sub-answer\">1. To include dagger.js via script tag in your html file:<br/><span style='font-style: italic; background-color: #eeeeee;'>&lt;script type=\"module\" crossorigin=\"anonymous\" src=\"https://cdn.jsdelivr.net/npm/@peakman/dagger.js/dagger.js\" defer&gt;&lt;/script&gt;</span><br/>2. To insert the <a href='miscellaneous/introduction'>root configs</a> tag under the head tag to declare the <a href='router/introduction'>routing scenarios</a> and the <a href='module/introduction'>module</a> dependency to render views.<br/>3. To declare <a href='directive/introduction'>directives</a> on DOM tags to define the interaction between page elements and data models.</div></span>"
    }, {
        "question": "View the online demo",
        "answer": "<span class='demo'><a target='_blank' href='https://www.w3schools.com/code/tryit.asp?filename=GNWIVUDVVKH5'>w3school</a><a target='_blank' href='https://codepen.io/dagger8224/pen/XWNagBY?editors=1000'>codepen</a></span>"
    }, {
        "question": "How to learn dagger.js",
        "answer": "<span>This site provides a succinct tutorials and the corresponding examples for dagger.js. In fact, <a target='_blank' href='https://github.com/dagger8224/dagger8224.github.io'>the project of this document site</a> is a typical demonstration for how to use dagger.js. Don't worry, it is very easy to learn and to use. Now let's start the <a href='directive/introduction'>tutorials</a> of dagger.js.</span>"
    }],
    "overview.version": "Overview/version",
    "overview.version.content": "The latest version of dagger.js is ",
    "overview.version.files": "<span>There are 4 files within the <a target='_blank' href='https://www.npmjs.com/package/@peakman/dagger.js'>distribution package</a>, please make your choice according to the working environment:</span>",
    "dagger.js": "This is the uncompressed development version with runtime defensive assertions, suitable for development environment.",
    "dagger.min.js": "This is the compressed development version with runtime defense assertions, suitable for development environment.",
    "dagger.release.js": "This is the uncompressed release version, which removes the runtime defense assertion to improve performance, suitable for production environment.",
    "dagger.release.min.js": "This is the compressed release version, which removes the runtime defense assertion to improve performance, suitable for production environment.",
    "compatibility": "Compatibility",
    "compatibility.content": "<span>dagger.js is compatible with the browsers supporting <a target='_blank' href='https://262.ecma-international.org/6.0/'>ECMA2015</a> and later version.</span>",
    "directive.introduction": "Directive/introduction",
    "directive.introduction.sections": [{
        "question": "What is directive",
        "answer": "<span>directive is an important concept in dagger.js. Formally, directive is special <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes'>attribute</a> (with specified prefix). At runtime, directives will be converted to expressions under context scopes, and interactive with the related DOM element. In later tutorials, we will see the examples of usage for different directives.</span>"
    }, {
        "question": "The category of directives",
        "answer": "<span>There are four types of directives: <a href='directive/raw'>meta directive</a> (with symbol \"@\" as prefix, such as \"@raw\"), <a href='directive/lifeCycle'>lifeCycle directives</a> (with symbol \"$\" as prefix, such as \"$loading\"), <a href='directive/controller'>control directives</a> (with symbol \"$\" as prefix, such as \"$value\") and <a href='directive/eventHandler'>event directive</a> (with symbol \"+\" as prefix, such as \"+click\").</span>"
    }, {
        "question": "The structure of directives",
        "answer": "<span>A typical directive is composed of </span><span class='format'>\"prefix + name + decorators (optional) + expression\"</span><span>. <a href='directive/decorator'>decorators</a> are a group of key value pairs separated by symbol \"#\", which are used to customize the behavior of directive. The meta directive is composed of </span><span class='format'>\"prefix + name\"</span><span> only.</span>"
    }, {
        "question": "The trigger source of directives",
        "answer": "<span>The meta directive is called by framework when parsing html template. The event directive is triggered by user operation or system event calling. The lifeCycle directives are called by framework during the create/destroy of related elements. The control directives are triggered by the depended data model, and might be called multiple times during the entire life time.</span>"
    }, {
        "question": "The restriction of directive expressions",
        "answer": "<span>Any legal single javaScript statement could be used as directive expression (no \"return\" before the statement), including sync/async function, or an object literal. To use inline compound statement, please break it down to multiple comma expression or wrap it as an IIFE. In fact, it is better to put the complex code logic inside a <a href='module/script'>script</a> module, and call it in the directive expression.</span>"
    }, {
        "question": "The variable scopes of directive expressions",
        "answer": "<span>Directive expression works under the runtime scopes. Except of the top layer javaScript <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Glossary/Global_scope'>global scope</a> and the second layer dagger.js <a href='miscellaneous/introduction'>root scope</a>, each element could create context scope dynamically with <a href='directive/loading'>$loading</a> lifeCycle directive. The variable scopes within different layers make up a runtime scope tree, each directive expression could visit the variables defined on the located and upper scopes.</span>"
    }, {
        "question": "Is directive required or optional",
        "answer": "<span>All directives are optional, an element without any directive is called plain element.</span>"
    }],
    "directive.raw": "Directive/@raw",
    "directive.raw.sections": [{
        "question": "The effect of @raw directive",
        "answer": "<span>The @raw directive is the only meta directive in current version, dagger.js will not parse the DOM element with @raw directive and its children, all other directives will be treated as plain attributes. Adding @raw directive on plain elements would improve response performance.</span>"
    }, {
        "question": "The available elements for @raw directive",
        "answer": "<span>Any DOM element could declare @raw directive.</span>"
    }],
    "directive.lifeCycle": "Directive/lifeCycle",
    "directive.lifeCycle.sections": [{
        "question": "What are lifeCycle directives",
        "answer": "<span>The lifeCycle directives are a group of directives triggered when the related DOM element is creating/destroying or connected state changed.</span>"
    }, {
        "question": "The list of lifeCycle directives",
        "answer": "<span><a href='directive/loading'>$loading</a><a href='directive/loaded'>$loaded</a><a href='directive/unloading'>$unloading</a><a href='directive/unloaded'>$unloaded</a><a href='directive/sentry'>$sentry</a></span>"
    }, {
        "question": "The order of lifeCycle directives when creating elements",
        "answer": "<span>parent's $loading -> children's $loading -> children's $loaded -> parent's $loaded</span>"
    }, {
        "question": "The order of lifeCycle directives when destroying elements",
        "answer": "<span>(global $sentry checking) -> parent's $unloading -> children's $unloading -> children's $unloaded -> parent's $unloaded</span>"
    }, {
        "question": "The available elements for lifeCycle directives",
        "answer": "<span>Any DOM element could declare lifeCycle directive.</span>"
    }],
    "directive.loading": "Directive/$loading",
    "directive.loading.sections": [{
        "question": "The effective of $loading directive",
        "answer": "<span>The $loading directive is triggered by framework before the related element is created. The main usage of $loading is to create a new variable scope in the context.</span>"
    }, {
        "question": "The return value of $loading directive expression",
        "answer": "<span>A context scope would be created based on the return value in case it's a plain object (not include the extended object such as Array), the variables insides the scope could be visited in the other directive expressions (except for the <a href='directive/each'>$each</a> and <a href='directive/exist'>$exist</a> directives) on the related element and all directive expressions of its children. The variables defined in the inner scope will override the variables with the same name defined in outer scopes.</span>"
    }],
    "directive.loaded": "Directive/$loaded",
    "directive.loaded.sections": [{
        "question": "The effective of $loaded directive",
        "answer": "<span>The $loaded directive is triggered by framework after the related element is created (the trigger condition is router changed in case the related element is &lt;html&gt;), which is used to do the initialization work for the related element of scope variables. A context parameter refers to the related element named \"$node\" is available in the $loaded expression (the parameter name could be customized with <a href='directive/decorator'>directive decorator</a>).</span>"
    }, {
        "question": "The return value of $loaded directive expression",
        "answer": "<span>The return value of $loaded directive expression is useless.</span>"
    }],
    "directive.unloading": "Directive/$unloading",
    "directive.unloading.sections": [{
        "question": "The effective of $unloading directive",
        "answer": "<span>The $unloading directive is triggered by framework before the related element is removed (the trigger condition is before router changed in case the related element is &lt;html&gt;), which is used to do the cleanup work for the related element of scope variables. A context parameter refers to the related element named \"$node\" is available in the $unloading expression (the parameter name could be customized with <a href='directive/decorator'>directive decorator</a>).</span>"
    }, {
        "question": "The return value of $unloading directive expression",
        "answer": "<span>The return value of $unloading directive expression is useless.</span>"
    }],
    "directive.unloaded": "Directive/$unloaded",
    "directive.unloaded.sections": [{
        "question": "The effective of $unloaded directive",
        "answer": "<span>The $unloaded directive is triggered by framework after the related element is removed (the trigger condition is before router changed in case the related element is &lt;html&gt;), which is used to do the cleanup work for the related element of scope variables. A context parameter refers to the removed related element named \"$node\" is available in the $unloaded expression (the parameter name could be customized with <a href='directive/decorator'>directive decorator</a>).</span>"
    }, {
        "question": "The return value of $unloaded directive expression",
        "answer": "<span>The return value of $unloaded directive expression is useless.</span>"
    }],
    "directive.sentry": "Directive/$sentry",
    "directive.sentry.sections": [{
        "question": "The effective of $sentry directive",
        "answer": "<span>Each $sentry directive expression registers a global callback, which will be triggered once the router attempts to change. The framework will determine if the router should change or not based on the return value of these callbacks. A context parameter refers to the related element named \"$nextRouter\" is available in the $sentry expression (the parameter name could be customized with <a href='directive/decorator'>directive decorator</a>).</span>"
    }, {
        "question": "The return value of $sentry directive expression",
        "answer": "<span>The router will stop changing once the expression return true or equivalent value.</span>"
    }],
    "directive.controller": "Directive/controller",
    "directive.controller.sections": [{
        "question": "What is control directive",
        "answer": "<span>The control directives (or controller) are the extension of element attributes, which provide the ability of dynamic response. Furthermore, some control directives provide the feature of two-way data binding between the related element and scoped variables.</span>"
    }, {
        "question": "The list of control directives",
        "answer": "<a href='directive/checked'>$checked</a><a href='directive/class'>$class</a><a href='directive/each'>$each</a><a href='directive/exist'>$exist</a><a href='directive/file'>$file</a><a href='directive/focus'>$focus</a><a href='directive/html'>$html</a><a href='directive/selected'>$selected</a><a href='directive/style'>$style</a><a href='directive/text'>$text</a><a href='directive/value'>$value</a><a href='directive/watch'>$watch</a><a href='directive/boolean'>boolean</a><a href='directive/general'>general</a>"
    }, {
        "question": "The list of two-way data binding control directives",
        "answer": "<a href='directive/checked'>$checked</a><a href='directive/file'>$file</a><a href='directive/selected'>$selected</a><a href='directive/value'>$value</a>"
    }, {
        "question": "The return value of control directive expression",
        "answer": "<span>The return value of control directive (except for $watch directive) expression would have specified impact on the property or behavior of the related element.</span>"
    }, {
        "question": "The trigger opportunity of control directive expression",
        "answer": "<span>Most of the control directives (except for $each and $exist directives) are triggered by framework firstly after the $loading directive (in case there is), and before the $loaded directive (in case there is). The control directives might be triggered multiple times during the lifetime of related element if the dependency variables of directive expression updated. In case there are multiple control directives declared on the same element, the first time trigger order is the same as the order of declaration.</span>"
    }, {
        "question": "The available elements to apply control directives",
        "answer": "<span>Unless specified in the document, all DOM elements but &lt;html&gt; tag are available for control directives.</span>"
    }],
    "directive.checked": "Directive/$checked",
    "directive.checked.sections": [{
        "question": "The effective of $checked directive",
        "answer": "<span>The $checked directive is used to bind with the check state of related element, it's suitable for radio, checkbox and option under select element. For other elements, $checked directive will act as a <a href='directive/general'>general directive</a>.</span>"
    }, {
        "question": "The return value of $checked directive expression",
        "answer": "<span>The related element will be checked when the expression return true or equivalent value, otherwise will be unchecked. When the expression returns a valid left-hand side of assignment, user's operation on the related element will sync to the variable.</span>"
    }, {
        "question": "The relationship between $checked directive and checked/selected attribute",
        "answer": "<span>For the elements declared $checked directive, the builtin \"checked/selected\" are ignored.</span>"
    }],
    "directive.class": "Directive/$class",
    "directive.class.sections": [{
        "question": "The effective of $class directive",
        "answer": "<span>The $class directive is used to bind with the class names of related element.</span>"
    }, {
        "question": "The return value of $class directive expression",
        "answer": "<span>The return value will be taken as class names if it's string. For array, each item will be converted to string and taken as class names. For object, all field keys with corresponding value true or equivalent value will be taken as class names. For other cases, the return value will be converted to string to proceed. No recursive processing for nested array or object.</span>"
    }, {
        "question": "The relationship between $class directive and class attribute",
        "answer": "<span>The return value of $class expression will be merged with the \"class\" attribute as the proceeded class names.</span>"
    }],
    "directive.each": "Directive/$each",
    "directive.each.sections": [{
        "question": "The effective of $each directive",
        "answer": "<span>The $each directive is used to render iteratable variables with the same view template.</span>"
    }, {
        "question": "The return value of $each directive expression",
        "answer": "<span>The framework will render multiple element instances based on the related element in case the return value is iteratable, and to create a new scope based on each iterator. There are 3 predefined variables in the scope, \"item\" as the slice data itself, \"index\" as the iteration index, and \"key\" as the field name in parent variable. The variables could be renamed with <a href='directive/decorator'>directive decorator</a>.</span>"
    }, {
        "question": "The other directives of the related element",
        "answer": "<span>For the directives other than $each on the template element, there will be a standalone instance created under each child scope.</span>"
    }],
    "directive.exist": "Directive/$exist",
    "directive.exist.sections": [{
        "question": "The effective of $exist directive",
        "answer": "<span>The $exist directive is used to toggle the existing state of the related element.</span>"
    }, {
        "question": "The return value of $exist directive expression",
        "answer": "<span>The related element will be created in case the directive expression return true or equivalent value, otherwise it will be destroyed.</span>"
    }, {
        "question": "The relationship between $exist directive and lifeCycle directives",
        "answer": "<span>Each time when the return value of $exist directive expression toggled, the lifeCycle directives will be triggered (\"$loading/$loaded\" for creating, \"$unloading/$unloaded\" for destroying).</span>"
    }],
    "directive.file": "Directive/$file",
    "directive.file.sections": [{
        "question": "The effective of $file directive",
        "answer": "<span>The $file directive is used to bind with the local file(s) selected via the related element.</span>"
    }, {
        "question": "The return value of $file directive expression",
        "answer": "<span>The return value of directive expression will refer to the selected File (single file selector) or FileList (multiple file selector) in case it is a valid left-hand side of assignment.</span>"
    }, {
        "question": "The restriction of $file directive",
        "answer": "<span>The $file directive is valid  only for the input element with type \"file\".</span>"
    }],
    "directive.focus": "Directive/$focus",
    "directive.focus.sections": [{
        "question": "The effective of $focus directive",
        "answer": "<span>The $focus directive is used to set focus/blur state of the related element.</span>"
    }, {
        "question": "The return value of $focus directive expression",
        "answer": "<span>The related element will be set focused in case the directive expression return true or equivalent value.</span>"
    }, {
        "question": "The relationship between $focus directive and autofocus attribute",
        "answer": "<span>For the elements declared $focus directive, the builtin \"autofocus\" attribute is ignored.</span>"
    }],
    "directive.html": "Directive/$html",
    "directive.html.sections": [{
        "question": "The effective of $html directive",
        "answer": "<span>The $html directive is used to create child html fragment dynamically for the related element. The builtin inner content of related element will be replaced by the return value of $html directive expression. It's usually used together with the <a href='router/introduction'>router configs</a>.</span>"
    }, {
        "question": "The return value of $html directive expression",
        "answer": "<span>The return value of directive expression will be treated as the inner html of the related element. The directives declared on the html template will take effect after the child related element created, the variable scopes are inherited from the parent's scope chain.</span>"
    }],
    "directive.selected": "Directive/$selected",
    "directive.selected.sections": [{
        "question": "The effective of $selected directive",
        "answer": "<span>The $selected directive is used to bind with the value of the selected related element, it's suitable for radio, checkbox and select element. For other elements, $selected directive will act as a <a href='directive/general'>general directive</a>.</span>"
    }, {
        "question": "The return value of $selected directive expression",
        "answer": "<span>The related element will be selected when the return value equal to the value (for radio or single select elements) or includes the value (for checkbox or multiple select elements), otherwise will be unchecked. When the expression returns a valid left-hand side of assignment, user's operation on the related element will sync to the variable.</span>"
    }, {
        "question": "The relationship between $selected directive and checked/selected attribute",
        "answer": "<span>For the elements declared $selected directive, the builtin \"checked/selected\" are ignored.</span>"
    }, {
        "question": "The relationship between $selected directive and $checked directive",
        "answer": "<span>The $selected expression is binding to the selected value(s) of related element(s), while the $checked directive is binding to the checked state. To apply $selected and $checked directives together might mess up the checked state and binding data of the related elements.</span>"
    }],
    "directive.style": "Directive/$style",
    "directive.style.sections": [{
        "question": "The effective of $style directive",
        "answer": "<span>The $style directive is used to bind with the style property of related element.</span>"
    }, {
        "question": "The return value of $style directive expression",
        "answer": "<span>The return value will be taken as style property if it's string. For array, each item will be converted to string and taken as style property. For object, all field key/value pairs will be stitched and taken as style property. For other cases, the return value will be converted to string to proceed. No recursive processing for nested array or object.</span>"
    }, {
        "question": "The relationship between $style directive and style attribute",
        "answer": "<span>The return value of $style expression will be merged with the \"style\" attribute as the proceeded style property.</span>"
    }],
    "directive.text": "Directive/$text",
    "directive.text.sections": [{
        "question": "The effective of $text directive",
        "answer": "<span>The $text directive is used to create child text content dynamically for the related element. The builtin inner content of related element will be replaced.</span>"
    }, {
        "question": "The return value of $text directive expression",
        "answer": "<span>The return value of directive expression will be taken as the inner text of the related element.</span>"
    }, {
        "question": "Inline $text directive expression",
        "answer": "<span>The text content of html tags with form of string template literal will be recognized as implicit $text directive expression.</span>"
    }],
    "directive.value": "Directive/$value",
    "directive.value.sections": [{
        "question": "The effective of $value directive",
        "answer": "<span>The $value directive is used to bind with the value property of the related element.</span>"
    }, {
        "question": "The return value of $value directive expression",
        "answer": "<span>The return value of $value directive expression will be taken as the value property of the related element. The \"input\", \"textarea\" and \"option\" tags are available for $value directive.  When the expression returns a valid left-hand side of assignment, user's operation on the related element will sync to the variable. <br/>Please note that for the element declared the $value directive and the <a href='directive/selected'>$selected</a> directive both, the variable binding to the $selected expression should be the return value of $value directive expression but not the converted value property (as string).</span>"
    }, {
        "question": "The relationship between $value directive and value attribute",
        "answer": "<span>For the element declared $value directive, the builtin \"value\" attribute is ignored.</span>"
    }, {
        "question": "The restriction of $value directive",
        "answer": "<span>It's illegal to use $value directive on \"input\" element with type \"file\".</span>"
    }],
    "directive.boolean": "Directive/boolean",
    "directive.boolean.sections": [{
        "question": "The effective of boolean directive",
        "answer": "<span>The boolean directives are used to bind with the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes#boolean_attributes'>boolean attributes</a> of the related element. The name of directive is the same as the corresponding attribute. For instance, \"$disabled\" directive is binding with the \"disabled\" attribute.</span>"
    }, {
        "question": "The return value of boolean directive expression",
        "answer": "<span>The return value of boolean directive expression will be converted to boolean value. The framework will add boolean attribute with the same name on the related element if the converted value is true, otherwise will remove the boolean attribute with the same name.</span>"
    }, {
        "question": "The relationship between boolean directive and boolean attribute with the same name",
        "answer": "<span>For the element declared boolean directive, the builtin boolean attribute with the same name is ignored.</span>"
    }, {
        "question": "The list of boolean directives",
        "answer": "<span>autocapitalize, autocomplete, contenteditable, controls, disabled, draggable, loop, multiple, muted, open, preload, readonly, required, reversed, spellcheck, translate, wrap</span>"
    }],
    "directive.general": "Directive/general",
    "directive.general.sections": [{
        "question": "The effective of general directive",
        "answer": "<span>The general directive is used to bind with the attribute with the same name of the related element. For instance, $id directive is binding to the \"id\" attribute.</span>"
    }, {
        "question": "The return value of general directive expression",
        "answer": "<span>The return value of general directive expression will be converted to string and assigned to the attribute with the same name.</span>"
    }, {
        "question": "The relationship between general directive and the attribute with the same name",
        "answer": "<span>For the element declared \"xxx\" directive, the builtin \"xxx\" attribute is ignored.</span>"
    }, {
        "question": "The restriction of general directive",
        "answer": "<span>Please note that the actions of some control directives depends on the specified attributes of the related element. For instance, the \"$checked/$selected\" directives depends on the type of \"input\" element, in this case, to declare \"$type\" directive would cause unexpected behavior of the \"$checked/$selected\" directives. Generally speaking, to declare static attributes instead of general directive in possible cases would reduce the unnecessary complexity and improve the runtime performance.</span>"
    }],
    "directive.watch": "Directive/$watch",
    "directive.watch.sections": [{
        "question": "The effective of $watch directive",
        "answer": "<span>The $watch directive is used to process specified logic when the dependency variables updated.</span>"
    }, {
        "question": "The return value of $watch directive expression",
        "answer": "<span>The return value of $watch directive expression will be ignored.</span>"
    }, {
        "question": "The restriction of $watch directive",
        "answer": "<span>Different from other control directives, it's valid to declare multiple $watch directives with different decorators on the same element, each of them works independently.</span>"
    }],
    "directive.eventHandler": "Directive/eventHandler",
    "directive.eventHandler.sections": [{
        "question": "The effective of eventHandler directive",
        "answer": "<span>The eventHandler directives are used to delegate the event listener with the same name declared on related element. For instance, \"+click\" directive will register a listener for \"click\" event on the related element. A context parameter refers to the triggered event named \"$event\" is available in the eventHandler expression (the parameter name could be customized with <a href='directive/decorator'>directive decorator</a>).</span>"
    }, {
        "question": "The relationship between eventHandler directive and the event attribute with the same name",
        "answer": "<span>It's valid to declare them both on the same element. The difference is, eventHandler expression works under the context scope chain of the related element, while the builtin event attribute expression could visit variables under the global scope only.</span>"
    }, {
        "question": "The restriction of eventHandler directive",
        "answer": "<span>It's valid to declare multiple eventHandler directives with different decorators on the same element. The default listener target is the related element, you may specify another target with the decorator.<br/>Please note that virtual elements (<a href='module/template'>template</a> module etc.) are not valid listener target.</span>"
    }],
    "directive.decorator": "Directive/decorator",
    "directive.decorator.sections": [{
        "question": "The effective of directive decorator",
        "answer": "<span>Decorator is an optional part of directive, which is used to customize the behavior of corresponding directive. Decorator is not support by meta directive.</span>"
    }, {
        "question": "The structure of directive decorator",
        "answer": "<span>It's valid to declare multiple decorators separated by \"#\" for the same directive. A full decorator is a key/value pair separated by \":\", the value of which could be omitted (the default value is boolean \"true\" unless specified). For instance, the directive '$value#trim#number:false=\"value\"' declares two decorators: trim == true and number == false.</span>"
    }, {
        "question": "The predefined general directive decorator",
        "answer": "<span>The directives work under \"insensitive\" mode by default. That is, during the proceeding of directive expression, any update on variables won't trigger the related directive expressions immediately, instead, the expressions will be pushed into a pending proceeding queue which to be triggered after the proceeding of current directive expression.<br/>You may declare \"sensitive(:true)\" decorator to set the work mode as sensitive, under which the framework will break to proceed the related directive expressions once detecting update on variables, and getting back to the stopped call stack after the process finished.</span>"
    }, {
        "question": "The predefined lifeCycle directive decorator",
        "answer": "<span>The decorator \"next\" is used to specify the name of callback parameter referring to the target <a href='router/introduction'>router</a> object for \"<a href='directive/sentry'>$sentry</a>\" lifeCycle directive, the default value is \"$nextRouter\"; The decorator \"node\" is used to set the name of callback parameter referring to the related element for \"<a href='directive/loaded'>$loaded</a>\", \"<a href='directive/unloading'>$unloading</a>\", \"<a href='directive/unloaded'>$unloaded</a>\", the default value is \"$node\".</span>"
    }, {
        "question": "The predefined control directive decorators",
        "answer": "<span>The $value directive supports the following decorators: <div class=\"sub-answer\">1. number, which is used to convert the input string to number;<br/>2. trim, which is used to remove whitespace from both ends of the input string;<br/>3. input, which is used to update the input content to the return value of directive expression right after user input, by default the update is triggered after the input element lost focus (response on \"change\" event).</div>The $each directive supports the following decorators: <div class=\"sub-answer\">1. item, which is used to set the name of the slice variable (the default name is \"item\"); <br/>2. index, which is used to set the name of index (with type number) of the the slice variable (the default name is \"index\"); <br/>3. key, which is used to set the name of field key (with type string) of the the slice variable (the default name is \"key\").</div>The $checked directive supports decorator \"scope\", which is used to specify the parent element selector of the checkable group (by default is the parentNode of related element).<br/>The $focus directive support decorator \"prevent\", which is used to specify <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/focus'> whether or not the browser should scroll the document to bring the newly-focused element into view</a>.</span>"
    }, {
        "question": "The predefined eventHandler directive decorator",
        "answer": "<span>The eventHandler directives support the following decorators: <div class=\"sub-answer\">1. target, which is used to set the target of event listener, for instance, \"+resize#target:window\" will add listener for \"resize\" event on window;<br/>2. event, which is used to set the parameter name referring to the triggered event (the default name is \"$event\");<br/>3. current, which is used to specify the target of event triggering should be the same target of event listener;<br/>4. modifier, which is used to set <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState'>the current state of the specified modifier key</a> (including Ctrl/Alt/Shift/Command/CapsLock etc.). The value of modifier decorator could either be string or string array. If the value is string array, the directive expression won't be triggered unless all the modifier keys are active;<br/>5. code, which is used to set the regExp or regExp array matching with the <a target='_blank' href='https://developer.mozilla.org/en-us/docs/Web/API/KeyboardEvent/code'>event.code</a>. If the value is regExp array, the directive expression won't be triggered unless all the regExps matched;<br/>6. key, which is used to  set the regExp or regExp array matching with the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key'>event.key</a> for keyboard event or <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons'>event.buttons</a> for mouse event (the enum for mouse event are \"Left/Right/Middle/Back/Forward\"). If the value is regExp array, the directive expression won't be triggered unless all the regExps matched;<br/>7. prevent, which is used to specify that the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault'>event.preventDefault</a> method will be called in the directive expression;<br/>8. stop, which is used to specify that the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation'>event.stopPropagation</a> method will be called in the directive expression;<br/>9. stopImmediate, which is used to specify that the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/Event/stopImmediatePropagation'>event.stopImmediatePropagation</a> method will be called in the directive expression;<br/>10. capture/once/passive, which are used to set the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener'>options</a> of the event listener.</div></span>"
    }, {
        "question": "The restriction of directive decorator",
        "answer": "<span>Limited by the parsing rules of DOM attributes and the grammar of dagger.js, some special characters could not be used as the content of decorator directly, otherwise it will parse failed or got unexpected parsing result.<br/>Specifically, to use the characters \"<\", \">\", \":\", \"#\", \"\\\", \"\/\", space and uppercase letters in decorator, please encode them based on the rule of <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent'>encodeURIComponent</a>.<br/>For the uppercase letters, a more convenient way is to add the \"-\" prefix before the letters. For instance, \"+click#modifier:['-Caps-Lock','-Shift']\" will check the state of modifiers \"CapsLock\" and \"Shift\" on mouse click. <br/>Please note that the framework will convert the letter with \"-\" prefix before decoding, that is, the decorator value \"-Caps-Lock\" will be converted to \"CapsLock\", while the value \"%2dCaps%2dLock\" will be converted to \"-caps-lock\" instead.</span>"
    }],
    "module.introduction": "Module/introduction",
    "module.introduction.sections": [{
        "question": "What is module",
        "answer": "<span>The reusability of view template, script and style is a common requirement in actual development scenarios. dagger.js supports module resource definition flexibly via configuration declaration. The modules defined in different layers construct a global module resource tree.</span>"
    }, {
        "question": "How to define a module",
        "answer": "<span>A module is defined via a key/value pair, in which the key is the module name in the resource tree, the value is an object with fields of URI, type and content etc.<br/>There are also other forms for config value:<div class=\"sub-answer\">1. a module config with URI field only could degenerate to a simple string;<br/>2. a module with different configs for specified environments could be set as an array, each item of the array includes optional <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia'>\"media\"</a> field or \"condition\" expression field, the framework will take the first matched slice config as the resolved value to parse.</div></span>"
    }, {
        "question": "The way to locate module content",
        "answer": "<span>There are 4 ways to locate the module content: inline, external, embedded and alias.<br/> A valid module config should declare either \"content\" or \"uri\" (equal to the config value if it's a string) field.<div class=\"sub-answer\">1. The value of \"content\" field (in case existing) will be taken as the text content of module (inline mode), for inline mode, it's required to declare the \"type\" field (enum values: json/namespace/script/style/string/template) to specify the type of current module explicitly.<br/>2. If no \"content\" field declared, the locate rule will be inferred by the \"uri\" field.<div class=\"sub-answer\">a. If the uri content is valid resource path (matching regExp \"/^[$a-zA-Z_]{1}[\\w-$]*(\\.[$a-zA-Z_]{1}[\\w-$]*)*$/\", such as \"module._script1\"), the resource referred by the path will be taken as the content source of current module (alias mode), for alias mode, the type of current module could be inferred by the source module;<br/>b. If the uri content is valid remote resource path (matching regExp \"/^(http:\\/\\/|https:\\/\\/|\\/|\\.\\/|\\.\\.\\/)/i\", such as \"https://script.location.com/script.js\" or \"./template.html\"), the framework will fetch the resource content from the remote server (external mode), for external mode, the type of current module could be inferred by the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type'>Content-Type</a> entity of the response headers.<br/>c. The uri unmatched with resource path or remote path will be taken as <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector'>element query selector</a> for current <a href='module/namespace'>namespace</a> (embedded mode), for embedded mode, the type of current module could be inferred by the \"type\" attribute of the resource tag. Besides string, the value of \"uri\" field could also be declared as a string array composed of multiple resource identifiers, in this way, the framework will try to fetch the resources one by one until got valid response.</div></div></span>"
    }, {
        "question": "Other optional common fields of module config",
        "answer": "<span>1. \"base\" (string), which is used to specify the baseURI of the relative uri path for the related module config and its children (in case existing);<br/>2. \"candidates\" (object array), which is used to specify an object array, each item of the array includes optional \"media/condition\", the framework will merge the first matched slice config with the current config before parsing;<br/>3. \"integrity\" (string), which is used to validate the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity'>sha256 subResource Integrity</a> of remote resource content;<br/>4. \"prefetch\" (string), which is used to declare the current module resource should be pre-fetched without blocking rendering views for the current <a href='router/introduction'>routing scenarios</a>. The framework will convert the \"prefetch\" value as a regExp to match with the current hash path, only the matched routing scenarios will be blocked.</span>"
    }, {
        "question": "The list of module types",
        "answer": "<span class='list'><a href='module/template'>template</a><a href='module/script'>script</a><a href='module/style'>style</a><a href='module/json'>json</a><a href='module/string'>string</a><a href='module/namespace'>namespace</a></span>"
    }, {
        "question": "Declaring multiple module configs with the same type as a group",
        "answer": "<span>The type name with \"@\" prefix is used to declare a group of module configs with the specified type. For instance, the config \"@namespace: { a: {...}, b: {...} }\" will declare two namespace modules named \"a\" and \"b\".</span>"
    }, {
        "question": "The location of module configs",
        "answer": "<span>The root module config is defined in the \"modules\" field of the <a href='router/introduction'>router config</a>, children module configs are declared under the parent module configs nested.</span>"
    }, {
        "question": "The way to visit module objects",
        "answer": "<span>The global module resource tree of the current <a href='router/introduction'>routing scenarios</a> could be visited via the \"$modules\" object under the <a href='miscellaneous/introduction'>root scope</a>, which could also be visited anonymously. For instance, a module named \"script\" under \"$modules\" may referred as \"$modules.script\" or \"script\" directly.</span>"
    }, {
        "question": "The order of module loading and view rendering",
        "answer": "<span>The framework will load and parse the modules declared within current router scenarios at the time of page loading or router changing. The view will start rendering right after all the modules loaded. The resolved modules will be cached at runtime and won't be loaded and parsed again when router changed.</span>"
    }],
    "module.template": "Module/template",
    "module.template.sections": [{
        "question": "What is template module",
        "answer": "<span>Template is reusable view module composed of html tags (including builtin DOM elements and other template modules).</span>"
    }, {
        "question": "The infer rule of template module",
        "answer": "<span>The module without specified type would be inferred as template module in case the resource container is template tag (for embedded mode), or the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type'>Content-Type</a> of remote response contains \"text/html\" and the root element of the resource document is not the html tag (otherwise will be inferred as \"namespace\").</span>"
    }, {
        "question": "The config fields of template module",
        "answer": "<span>Besides the common config fields of module, there is a \"style\" field (should be string or string array) to refer to the relative path(s) of style module(s) active for current template module.</span>"
    }, {
        "question": "The restriction of template module",
        "answer": "<span>1. Recursion and circular references are not supported, however, it's easy to construct reference structures using conditional \"<a href='directive/html'>$html</a>\" directive.<br/>2. Limited by the parsing rule of html tags and the consideration of compatibility, the characters \"$\" and \"-\" are disabled in the module path. Please add the prefix \"-\" before the uppercase characters when declaring module path as html tag, for instance, the html tag \"&lt;my-module.-template&gt;\" will be mapped to the module path \"myModule.Template\".<br/>3. The template tag will be replaced by its content when parsing and won't be converted to a real DOM element, so it should not be specified as the target of <a href='directive/eventHandler'>eventHandler</a> directives.</span>"
    }],
    "module.namespace": "Module/namespace",
    "module.namespace.sections": [{
        "question": "What is namespace module",
        "answer": "<span>Namespace is a module set composed of sub modules. Each namespace constitutes a new module scope, to visit the variables or methods under the sub modules of a namespace, both the absolute way (via the \"$modules\" object under the <a href='miscellaneous/introduction'>root scope</a>) or relative way (via the relative path to the namespace) are supported.</span>"
    }, {
        "question": "The infer rule of namespace module",
        "answer": "<span>The module without specified type would be inferred as namespace module in case the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type'>Content-Type</a> of remote response contains \"text/html\" and the root element of the resource document is the html tag (otherwise will be inferred as \"template\").</span>"
    }, {
        "question": "The config fields of namespace module",
        "answer": "<span>Besides the common config fields of module, there is a \"customTags\" field (should be string array) to indicate the custom tag names under current namespace. The framework will treat the tag names declared in the customTags as builtin html tags, otherwise will take them as <a href='module/template'>template</a> module for further processing (replace the tag with the module content).</span>"
    }, {
        "question": "The restriction of namespace module",
        "answer": "<span>Namespace module will parse and load its sub modules recursively based on the <a href='miscellaneous/introduction'>configs</a> of the resource template, circular reference of namespaces is illegal.</span>"
    }],
    "module.style": "Module/style",
    "module.style.sections": [{
        "question": "What is style module",
        "answer": "<span>Style module is reusable style fragment.</span>"
    }, {
        "question": "The infer rule of style module",
        "answer": "<span>The module without specified type would be inferred as style module in case the resource container is style tag with type attribute \"dagger/style\" (for embedded mode), or the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type'>Content-Type</a> of remote response contains \"text/css\".</span>"
    }, {
        "question": "The config fields of style module",
        "answer": "<span>Besides the common config fields of module, there is a \"scoped\" field (boolean, default value is true) to specify if the style is scoped to the related <a href='module/template'>template</a> or takes effect globally.</span>"
    }, {
        "question": "The restriction of style module",
        "answer": "<span>It's illegal to use the character \"$\" in the path of style module.</span>"
    }],
    "module.script": "Module/script",
    "module.script.sections": [{
        "question": "What is script module",
        "answer": "<span>Script module is a reusable javaScript fragment.</span>"
    }, {
        "question": "The infer rule of script module",
        "answer": "<span>The module without specified type would be inferred as script module in case the resource container is script tag with type attribute \"dagger/script\" (for embedded mode), or the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type'>Content-Type</a> of remote response contains one of the following types: \"application/javascript\", \"javascript/esm\", \"text/javascript\".</span>"
    }, {
        "question": "The config fields of script module",
        "answer": "<span>Besides the common config fields of module, the following fields are available for script module:<div class=\"sub-answer\">1. \"converter\" (expression string), which is used to convert the parsed module further, for instance, the converter \"converter: '{ b: $module.a }'\" will rename the method \"a\" as \"b\";<br/>2. \"anonymous\" (boolean, default value is false), the methods under an anonymous script could be called without the module name as context.</div></span>"
    }, {
        "question": "The restriction of script module",
        "answer": "<span>Script module is parsed based on the standard <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import'>import</a>/<a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export'>export</a> syntax. Technically, it is valid to import other <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules'>javaScript modules</a>. To import an external script defined via relative path, please wrap the url with a predefined macro \"BASE\" so that the framework will replace it with the context baseURL. For instance, to import \"./script.js\" inside a script module, please wrap it as \"import 'BASE(./script.js)'\".</span>"
    }],
    "module.string": "Module/string",
    "module.string.sections": [{
        "question": "What is string module",
        "answer": "<span>String module is a reusable string resource.</span>"
    }, {
        "question": "The infer rule of string module",
        "answer": "<span>The module without specified type would be inferred as string module in case it cannot be inferred as other module types.</span>"
    }],
    "module.json": "Module/json",
    "module.json.sections": [{
        "question": "What is json module",
        "answer": "<span>json module is a reusable JSON data structure, will resolved as an javaScript object after parsing.</span>"
    }, {
        "question": "The infer rule of json module",
        "answer": "<span>The module without specified type would be inferred as json module in case the resource container is script tag with type attribute \"dagger/json\" (for embedded mode), or the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type'>Content-Type</a> of remote response contains \"application/json\".</span>"
    }, {
        "question": "The config fields of json module",
        "answer": "<span>Besides the common config fields of module, the following fields are available for json module: 1. \"converter\" (expression string), which is used to convert the parsed module further, for instance, the converter \"converter: '{ b: $module.a }'\" will rename the field \"a\" as \"b\"; 2. \"anonymous\" (boolean, default value is false), the fields under an anonymous json module could be called without the module name as context.</span>"
    }],
    "router.introduction": "Routing/introduction",
    "router.introduction.sections": [{
        "question": "What is routing",
        "answer": "<span>dagger.js integrates with a builtin routing state manager based on url <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/Location/hash'>hash</a>, the routing mapping rules are declared via configs. In fact, the routing configs are the <a href='module/introduction'>module</a> resource requirements to render the current view scenario (corresponding to the specified hash value).</span>"
    }, {
        "question": "The location of routing configs",
        "answer": "<span>The routing configs are declared via \"routing\" field of the root <a href='miscellaneous/introduction'>configs</a>.</span>"
    }, {
        "question": "The way to redirect routing",
        "answer": "<span>Clicking on the links with the \"href\" attribute refer to the hash value (the relative path starts with \"./\" or \"/\" would be recognized as url path but not hash), or executing the statement \"location.hash = 'xxx';\" in javaScript methods would update the hash state. Once the routing configs matched with the target hash value found, the declared modules and other resources would be loaded and resolved. The framework will initialize the context variable scopes, and work together with the \"<a href='directive/html'>$html</a>\" directive to render the context view.<br/>Please note that the routing redirect will trigger the validation of \"<a href='directive/sentry'>$sentry</a>\", and the redirect would be blocked in case the validation failed.</span>"
    }],
    "router.structure": "Routing/structure",
    "router.structure.sections": [{
        "question": "The global config fields",
        "answer": "<span>The following global fields are supported in routing configs:<div class=\"sub-answer\">1. \"aliases\" (optional, object), which is used to declare aliases for specified routers. As routing redirects, the \"aliases\" mapping will be checked firstly. For instance, \"aliases: { '/alias1': '/router', '/alias2': '/router' }\" declares two aliases \"alias1\" and \"alias2\" for path \"router\", in case the target hash path is \"alias1\" or \"alias2\", the routing manager will load the scenario configs matched path \"router\" for further processing. Alias match will not lead to routing redirect again;<br/>2. \"redirects\" (optional, object), which is used to declare the redirect mapping of routers. As routing redirects, in case the target hash path matched the key of \"redirects\", the routing will redirect to the path referred by the matched value. For instance, giving the configs \"redirects: { '/router1': '/router2' }\", as routing redirected to the path \"router1\", it will keep redirecting to the path \"router2\" for further processing;<br/>3. \"default\" (optional, string), which is used to specify the default routing path once no router path is matched. Default match will not lead to routing redirect again;<br/>4. \"hashPrefix\" (optional, string, the default value is \"#\"), which is used to specify the prefix of url hash;<br/>5. \"overrideRelativeLinks\" (optional, boolean, the default value is true), which is used to specify whether to take the relative paths as hash preferentially, the browser will take the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_URL'>url path match rules</a> once the option is closed.</div></span>"
    }, {
        "question": "scenarios fields and router match rules",
        "answer": "<span>The \"scenarios\" (object) filed is used to define the topology structure of routing scenarios. The full routing scenarios is a tree composed of multiple router scenario nodes, each node defines its matching rule, the variables and modules required for view rendering.<br/>When page loaded or routing redirected, the target hash path will break down into multiple sections separated by \"/\", each path section will match with the router node orderly, the match is success if each path section can be successfully matched with the corresponding node on a continuous routing subtree and the routing node matched by the last path section is declared \"tailable\", otherwise the routing will redirect to the path of \"default\". Each routing scenario node includes the following predefined fields:<div class=\"sub-answer\">1. \"path\" (optional, string or object, the default value is empty string), which is used to declare the name and matching rule of the current routing scenario. The value of \"path\" will be taken as scenario name and the matching regExp both in case it is string. If the value is an object, the key of the key/value pair in the object will be used as the scenario name, and the value will be converted into a regExp to match the corresponding path section;<br/>2. \"modules\" (optional, object), which is used to declare the <a href='module/introduction'>modules</a> to render view for the current routing scenario. If module configs with the same name are declared on multiple routing nodes, the one on the child node has a higher priority;<br/>3. \"constants\" (optional, object), which is used to declare the constant data corresponding to the current routing scenario. If the constants with the same name are declared on multiple routing nodes, the one on the child node has a higher priority;<br/>4. \"variables\" (optional, object), which is used to declare the variables corresponding to the current routing scenario. The value of variables can be overriding by the same data of the page hash <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams'>query parameters</a >. If the variables with the same name are declared on multiple routing nodes, the one on the child node has a higher priority;<br/>5. \"children\" (optional, router node array), which is used to declare the direct children of the current scenario;<br/>6. \"tailable\" (optional, boolean, the default value is true for leaf node, is false for other nodes), which is used to specify whether the current scenario node could be taken as the the termination of routing matching process.</div></span>"
    }, {
        "question": "The runtime $router object",
        "answer": "<span>After matched successfully, the framework will create a read-only object \"$router\" under the <a href='miscellaneous/introduction'>root scope</a>. The \"$router\" object contains the following fields:<div class=\"sub-answer\">1. \"hash\" (string), which records the full hash value (including path and queryString) of the current routing;<br/>2. \"hashPrefix\" (string), which records the specified prefix of hash;<br/>3. \"path\" (string), which records the hash path;<br/>4. \"paths\" (string array), which records the path sections separated by \"/\" (empty string for the root section);<br/>5. \"query\" (string), which records the queryString of hash;<br/>6. \"queries\" (object), each key/value pair records a group of query params;<br/>7. \"scenarios\" (object), which records the mapping of scenario name and hash path section;<br/>8. \"schemes\" (object), which records the variables and constants of the current scenarios. The constant has a higher priority than the variable with the same name under the same scenario;<br/>9. \"identity\" (<a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol'>Symbol</a>), the framework will create an unique \"identity\" symbol after each time routing redirected, which could be watched in <a href='directive/controller'>control directives</a> to ensure the expressions are triggered after routing redirected.</div></span>"
    }],
    "api.introduction": "API/introduction",
    "api.introduction.sections": [{
        "question": "The APIs provided in dagger.js",
        "answer": "<span>In the current version, there are only 2 API interfaces for special usage scenarios, encapsulated in the window.$dagger read-only object.</span>"
    }, {
        "question": "The \"$dagger.runtime\" interface",
        "answer": "<span>After loaded, dagger.js will look for the script tag with type \"dagger/configs\" under the head tag of the page as the root <a href='miscellaneous/introduction' >configs</a>, and perform the resource initialization and view rendering under the current <a href='router/introduction'>routing scenarios</a> as the document's \"DOMContentLoaded\" event is triggered.<br/>Besides the default automatic initialization method, users can also manually call the  \"$dagger.runtime\" method to perform runtime initialization manually (in this mode, please do not declare the script tag of type \"dagger/configs\" in the page head to avoid repeated initialization), the runtime method receives an object as a parameter, and the field content of the object is consistent with the content of the root <a href='miscellaneous/introduction'>configs</a>.</span>"
    }, {
        "question": "The \"$dagger.register\" interface",
        "answer": "<span>dagger.js has built-in responsive support for the instance methods of native javaScript object such as \"Object/Array/Date/Map/Set/WeakMap/WeakSet\". Users may also use \"the $dagger.register\" interface to register custom class methods. The registered methods will be responsive at runtime and can be dynamically dependent in the <a href='directive/controller'>control instruction</a> expression.<br/>The \"$dagger.register\" method requires to parameters, the first parameter is the class object to be registered, and the second parameter is a string array referred to the method names defined on the class object's <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain'>prototype</a>.</span>"
    }, {
        "question": "The \"$dagger.version\" field",
        "answer": "<span>\"$dagger.version\" is a string referred to the current version of dagger.js.</span>"
    }],
    "miscellaneous.introduction": "Miscellaneous/introduction",
    "miscellaneous.introduction.sections": [{
        "question": "The root scope",
        "answer": "<span>The root scope of dagger.js is the variable scope defined at the top level of the runtime closure, the variables and methods under the root scope can be visited within the directive expressions on any element. The root scope includes the <a href='router/structure'>routing</a> object \"$router\", the <a href='module/introduction'>module</a> resource tree object \"$modules\", and the data validation method in debug mode \"$validator\".</span>"
    }, {
        "question": "$validator",
        "answer": "<span>\"$validator\" is a builtin javaScript method under root scope, which supports the following parameters:<div class=\"sub-answer\">1. \"data\" (any), to specify the variable data to be validated;<br/>2. \"path\" (string), to specify the path or name of the validate data;<br/>3. \"validators\", the validator content, including:<div class=\"sub-answer\">a. \"type\", used to validate the type(s) of the variable;<br/>b. \"assert\" the assert method(s), accept data as input parameter, return true as validate successfully, otherwise validate failed;<br/>c. \"required\"，be true means that the data to be validated must be a valid value (should not b null, undefined or NaN).</div></div></span>"
    }, {
        "question": "The predefined className \"dg-cloak\"",
        "answer": "<span>\"dg-cloak\" is a predefined className of dagger.js, which is used to hide the rendering DOM elements, the framework will remove the \"dg-cloak\" from the related elements after they are rendered successfully. Though dagger.js will create dynamic styleSheet to ensure the className works as expected, it is recommended to manually insert the following style tag under the head of the page to avoid flickering during page rendering:</span><br/><span style='font-style: italic; background-color: #eeeeee;'>&lt;style&gt;[dg-cloak] { display: none !important; }&lt;/style&gt;</span>"
    }, {
        "question": "The root configs",
        "answer": "<span>The root configs is usually declared as a script tag with type \"dagger/configs\" under the head tag of the page (either inline or external content). In manual initialization mode, the root configs is a parameter of the \"$dagger.runtime\" interface method. The root configs supports the following fields:<div class=\"sub-answer\">1. \"rootSelectors\" (string array), used to specify the element selector corresponding to the root node for parsing, the default value is \"['title', 'body']\", the html tag cannot be used as the root element of parsing;<br/>2. \"customTags\" (string array), used to specify the global <a href='module/namespace'>custom tags</a>;<br/>3. \"routing\" (object), used to declare the <a href='router/structure'>routing configs</a>;<br/>4. \"options\" (object), used to set the runtime options of the framework (boolean), including:<div class=\"sub-answer\">a. \"commentNode\" (the default value is false, the comment node will be ignored at parsing if the value is false);<br/>b. \"directiveAttribute\" (the default value is false, the corresponding debug attributes will be added to the related element after initialized in case the value is true);<br/>c. \"moduleLog\" (the default value is false, the relevant log will be printed on the console during module loading in case the value is true);<br/>d. \"routerLog\" (the default value is false, the relevant log will be printed on the console when the route redirected in case the value is true);<br/>e. \"integrity\" (the default value is true, will perform <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity'>sha256 subResource Integrity</a> when remote module loading in case the value is true).</div></div></span>"
    }, {
        "question": "The difference between \"debug\" and \"release\" versions",
        "answer": "<span>In the release version, only the \"commentNode\" and \"integrity\" fields are supported in the root configs, the \"$validator\" is defined as an empty function, the runtime asserters in debug mode are also removed to improve response performance.</span>"
    }, {
        "question": "The engineering solution",
        "answer": "<span>dagger.js implements a distributed module reuse technology solution. Modules in different <a href='module/introduction'>types</a> are implemented based on native syntax. It is easy (though not necessary) for users to utilize the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Introducing_complete_toolchain'>modern front-end development tool chain</a> for better development experience and to improve development efficiency.</span>"
    }]
}
